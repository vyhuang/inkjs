import { CharacterSet } from "../CharacterSet";
import { ParsedObject } from "../ParsedHierarchy/Object";
import { StringParserState } from "./StringParserState";
import { StringParserElement } from "./StringParserElement";
export declare const ParseSuccess: unique symbol;
export type ParseRule = () => ParseRuleReturn;
export type ParseRuleReturn = object | string | null | number | (typeof StringParser)["ParseSuccess"];
export type SpecificParseRule<T extends ParseRule> = T;
export declare class StringParser {
    ParseRule: ParseRule | null;
    static readonly ParseSuccess: typeof ParseSuccess;
    static readonly numbersCharacterSet: CharacterSet;
    private _chars;
    errorHandler: null | ((message: string, index: number, lineIndex?: number, isWarning?: boolean) => void);
    state: StringParserState;
    hadError: boolean;
    constructor(str: string);
    get currentCharacter(): string;
    PreProcessInputString(str: string): string;
    readonly BeginRule: () => number;
    readonly FailRule: (expectedRuleId: number) => ParseRuleReturn;
    readonly CancelRule: (expectedRuleId: number) => void;
    readonly SucceedRule: (expectedRuleId: number, result?: ParseRuleReturn) => ParseRuleReturn;
    RuleDidSucceed?: (result: ParseRuleReturn, startState: StringParserElement | null, endState: StringParserElement) => void;
    readonly Expect: (rule: ParseRule, message?: string | null, recoveryRule?: ParseRule | null) => ParseRuleReturn;
    Error: (message: string, isWarning?: boolean) => void;
    readonly ErrorWithParsedObject: (message: string, result: ParsedObject, isWarning?: boolean) => void;
    readonly ErrorOnLine: (message: string, lineNumber: number, isWarning: boolean) => void;
    readonly Warning: (message: string) => void;
    get endOfInput(): boolean;
    get remainingString(): string;
    readonly LineRemainder: () => string;
    get remainingLength(): number;
    inputString: string;
    get lineIndex(): number;
    set lineIndex(value: number);
    set characterInLineIndex(value: number);
    get characterInLineIndex(): number;
    get index(): number;
    set index(value: number);
    readonly SetFlag: (flag: number, trueOrFalse: boolean) => void;
    readonly GetFlag: (flag: number) => boolean;
    ParseObject: (rule: ParseRule) => ParseRuleReturn;
    readonly Parse: <T extends ParseRule>(rule: SpecificParseRule<T>) => ParseRuleReturn;
    readonly OneOf: (array: ParseRule[]) => ParseRuleReturn;
    readonly OneOrMore: (rule: ParseRule) => ParseRuleReturn[] | null;
    readonly Optional: (rule: ParseRule) => ParseRule;
    readonly Exclude: (rule: ParseRule) => ParseRule;
    readonly OptionalExclude: (rule: ParseRule) => ParseRule;
    readonly String: (str: string) => ParseRule;
    private readonly TryAddResultToList;
    readonly Interleave: <T>(ruleA: ParseRule, ruleB: ParseRule, untilTerminator?: ParseRule | null, flatten?: boolean) => T[];
    readonly ParseString: (str: string) => string | null;
    readonly ParseSingleCharacter: () => string;
    readonly ParseUntilCharactersFromString: (str: string, maxCount?: number) => string | null;
    readonly ParseUntilCharactersFromCharSet: (charSet: CharacterSet, maxCount?: number) => string | null;
    readonly ParseCharactersFromString: (str: string, maxCountOrShouldIncludeStrChars?: boolean | number, maxCount?: number) => string | null;
    readonly ParseCharactersFromCharSet: (charSet: CharacterSet, shouldIncludeChars?: boolean, maxCount?: number) => string | null;
    readonly Peek: (rule: ParseRule) => ParseRuleReturn;
    ParseUntil(stopRule: ParseRule, pauseCharacters?: CharacterSet | null, endCharacters?: CharacterSet | null): string;
    readonly ParseInt: () => number | null;
    readonly ParseFloat: () => number | null;
    readonly ParseNewline: () => string;
}
